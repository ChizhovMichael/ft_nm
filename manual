Чтобы выполнить этот проект, вам нужно будет использовать Linux Docker/VM. Вы должны работать с двоичными файлами ELF. Вы должны обрабатывать x86_32, x64, объектные файлы, .so 
Используйте команду file для просмотра сведений о файле. Вы можете использовать двоичные файлы, расположенные в вашей системе (/usr/bin/, /usr/lib/...).

man nm
// OK
• Этот проект будет исправляться только людьми. Вам разрешено упорядочивать файлы и называть их по своему усмотрению, но вы должны соблюдать следующие правила.
// OK
• Исполняемый файл должен называться ft_nm.
// OK
• Вы должны программировать на C и использовать Makefile.
// OK
• Ваш Makefile должен компилировать проект и содержать обычные правила.
// OK
• Если вы сообразительны, вы будете использовать свою библиотеку для своего ft_nm. Отправьте также свою папку libft, включая собственный Makefile, в корень вашего репозитория. Ваш Makefile должен будет скомпилировать библиотеку, а затем скомпилировать ваш проект.

• Вывод должен быть похож на nm в списке символов (порядок, смещение, заполнение...). Другие аспекты могут иметь небольшие отличия (имя файла и т. д.).
• Ваша программа должна вести себя как система nm во всех остальных аспектах. Вы должны тщательно обрабатывать ошибки. Ни в коем случае ваша программа не может завершиться неожиданным образом (ошибка сегментации, ошибка шины, двойное освобождение и т. д.).
• Будь осторожен. Есть много способов вывести вашу программу из отображаемого содержимого, будь то строка с ненулевым завершением, неправильные смещения... Проверьте все.
• Убедитесь, что каждое значение, которое вы анализируете, правильное: например, при анализе флагов, архитектуры сопоставьте свой результат со ссылкой, чтобы убедиться, что его значение правильное.

// OK
nm - список символов из объектных файлов
GNU nm перечисляет символы из объектных файлов objfile .... Если объектные файлы не указаны в качестве аргументов, nm предполагает, что файл a.out .

Для каждого символа nm показывает:
• Значение символа в системе счисления, выбранной параметрами (см. ниже), или шестнадцатеричное по умолчанию.
• Тип символа. По крайней мере, используются следующие типы; другие также зависят от формата объектного файла. В нижнем регистре символ является локальным; если в верхнем регистре, символ является глобальным (внешним).

"A" Значение символа является абсолютным и не будет изменено дальнейшим связыванием.

"B" "b" Символ находится в разделе неинициализированных данных (известном как BSS ).

"C" Символ распространен. Общие символы представляют собой неинициализированные данные. При связывании может появиться несколько общих символов с одним и тем же именем. Если символ определен где-либо, общие символы рассматриваются как неопределенные ссылки.

"D" "d" Символ находится в разделе инициализированных данных.

"G" "g" Символ находится в разделе инициализированных данных для небольших объектов. Некоторые форматы объектных файлов обеспечивают более эффективный доступ к небольшим объектам данных, таким как глобальная переменная типа int, а не к большому глобальному массиву.

"i" Для файлов формата PE это означает, что символ находится в разделе, относящемся к реализации DLL. Для файлов формата ELF это указывает на то, что символ является косвенной функцией. Это расширение GNU для стандартного набора типов символов ELF . Он указывает символ, который, если на него ссылается перемещение, не оценивается по его адресу, а вместо этого должен вызываться во время выполнения. Затем выполнение во время выполнения вернет значение, которое будет использоваться при перемещении.

"N" Символ является символом отладки.

"p" Символы находятся в разделе раскрутки стека.

"R" "r" Символ находится в разделе данных только для чтения.

"S" "s" Символ находится в разделе неинициализированных данных для небольших объектов.

"T" "t" Символ находится в текстовой (кодовой) части.

"U" Символ не определен.

"u" Символ является уникальным глобальным символом. Это расширение GNU для стандартного набора привязок символов ELF . Для такого символа динамический компоновщик позаботится о том, чтобы во всем процессе использовался только один символ с таким именем и типом.

"V" "v" Символ — слабый объект. Когда слабо определенный символ связан с нормально определенным символом, нормально определенный символ используется без ошибок. Когда слабый неопределенный символ связан и символ не определен, значение слабого символа становится равным нулю без ошибки. В некоторых системах прописные буквы означают, что задано значение по умолчанию.

"W" "w" Символ является слабым символом, который не был специально помечен как слабый символ объекта. Когда слабо определенный символ связан с нормально определенным символом, нормально определенный символ используется без ошибок. Когда слабый неопределенный символ связан, а символ не определен, значение символа определяется системно-специфическим образом без ошибок. В некоторых системах прописные буквы означают, что задано значение по умолчанию.

"-" Символ представляет собой символ протыкания в объектном файле a.out. В этом случае следующие печатаемые значения — это поле stabs other, поле stabs desc и тип stabs. Символы Stabs используются для хранения отладочной информации.

"?" Тип символа неизвестен или зависит от формата объектного файла.

• Имя символа.

ELF — это сокращение от Executable and Linkable Format (формат исполняемых и связываемых файлов) и определяет структуру бинарных файлов, библиотек, и файлов ядра (core files). Спецификация формата позволяет операционной системе корректно интерпретировать содержащиеся в файле машинные команды. Файл ELF, как правило, является выходным файлом компилятора или линкера и имеет двоичный формат. С помощью подходящих инструментов он может быть проанализирован и изучен.

Вместо того, чтобы напрямую использовать язык CPU, мы используем язык программирования, имеющий стандартные функции. Компилятор затем транслирует эти функции в объектный код. Этот объектный код затем линкуется в полную программу, путём использования линкера. Результатом является двоичный файл, который может быть выполнен на конкретной платформе и конкретном типе CPU.

Заголовки секции определяют все секции файла. Как уже было сказано, эта информация используется для линковки и релокации. Секции появляются в ELF-файле после того, как компилятор GNU C преобразует код С в ассемблер, и ассемблер GNU создаёт объекты.

Сегмент может иметь 0 или более секций. Для исполняемых файлов существует четыре главных секций: .text, .data, .rodata, и .bss. Каждая из этих секций загружается с различными правами доступа, которые можно посмотреть с помощью readelf -S.

.text - Содержит исполняемый код. Он будет упакован в сегмент с правами на чтение и на исполнение. Он загружается один раз, и его содержание не изменяется. Это можно увидеть с помощью утилиты objdump.
.data - Инициализированные данные, с правами на чтение и запись.
.rodata - Инициализированные данные, с правами только на чтение. (=A).
.bss - Неинициализированные данные, с правами на чтение/запись. (=WA)


ABI — это Бинарный Интерфейс Приложения (Application Binary Interface) и определяет, низкоуровневый интерфейс между операционной системой и исполняемым кодом.

Стандарт формата ELF различает несколько типов файлов:

Типы
Перемещаемый файл — хранит инструкции и данные, которые могут быть связаны с другими объектными файлами. Результатом такой связи может быть разделяемый объектный файл или исполняемый файл. К этому типу относятся объектные файлы статических библиотек.
Разделяемый объектный файл — также содержит инструкции и данные и может быть связан с другими перемещаемыми файлами и разделяемыми объектными файлами, в результате чего будет создан новый объектный файл, либо при запуске программы на выполнение операционная система может динамически связать его с исполняемым файлом программы, в результате чего будет создан исполняемый образ программы. В последнем случае речь идет о разделяемых библиотеках.
Исполняемый файл — содержит полное описание, позволяющее системе создать образ процесса. В том числе: инструкции, данные, описание необходимых разделяемых объектных файлов и необходимую символьную и отладочную информацию.

.a является «архивом». Хотя архив может содержать файл любого типа, в контексте цепочки инструментов GNU это библиотека объектных файлов (другие цепочки инструментов, особенно в Windows, используются .libдля той же цели, но их формат обычно не является архивом общего назначения, и часто зависят от цепочки инструментов). Можно извлекать отдельные объектные файлы из архива, что, по сути, и делает компоновщик, когда использует библиотеку.

.o является объектным файлом. Это код, который скомпилирован в машинный код, но (как правило) не полностью связанный - он может иметь неразрешенные ссылки на символы, определенные в других объектных файлах (в библиотеке или индивидуально), сгенерированных отдельной компиляцией. Объектные файлы содержат метаданные для поддержки связи с другими модулями, а также, при необходимости, для символьной отладки на уровне исходного кода (например, в GDB). Другие наборы инструментов, опять же обычно в Windows, используют расширение .obj, а не .o.

.so является общей библиотекой объектов (или просто общей библиотекой). Это динамически связано с исполняемым файлом при запуске программы, а не статически связано во время сборки. Это позволяет использовать меньшие исполняемые файлы и один экземпляр библиотеки объектов для использования несколькими исполняемыми файлами. API-интерфейсы операционных систем, как правило, являются разделяемыми библиотеками, и они часто используются также в GNU по причинам лицензирования, например, для отделения кода LGPL от проприетарного кода с закрытым исходным кодом. В отличие от .oили .aфайлы, .soфайлы, используемые приложением, должны быть доступны в системе выполнения. Другие системы (опять же обычно Windows) используют .dll(динамическую библиотеку) для той же цели.

Расширение	none, .axf, .bin, .elf, .o, .out, .prx, .puff, .ko, .mod, and .so
Сигнатура	7f 45 4c 46


https://habr.com/ru/post/55716/
https://habr.com/ru/post/480642/
https://russianblogs.com/article/64531215793/
https://ru.wikipedia.org/wiki/Executable_and_Linkable_Format

Elf файл состоит из:
1. Заголовок файла (52-64б)
2. Таблица заголовков секций (для каждый строки 40-64б)
3. Таблица заголовков программы (для каждый строки 32-56б)
4. Таблица символов

Заголовок имеет размер 52 байта для 32-битных файлов или 64 для 64-битных. Данное различие обуславливается тем, что в заголовке файла содержится три поля, имеющих размер указателя, который составляет 4 и 8 байт для 32- и 64-битных процессоров соответственно. Такими полями являются e_entry, e_phoff и e_shoff.


Таблица заголовков программы содержит заголовки, каждый из которых описывает отдельный сегмент программы и его атрибуты либо другую информацию, необходимую операционной системе для подготовки программы к исполнению. Данная таблица может располагаться в любом месте файла, её местоположение (смещение относительно начала файла) описывается в поле e_phoff заголовка ELF. При анализе структуры заголовка программы можно обнаружить различное местоположение поля p_flags для 32- и 64-битных ELF файлов. Данное различие обуславливается выравниванием структуры для увеличения эффективности обработки. Присутствует только в испольняемых файлах и файлах .so

//============================
// Сегменты (Program Headers)
//============================

Таблица заголовков программы исполняемого или совместно используемого объектного файла представляет собой массив структур, каждая из которых описывает сегмент или другую информацию, необходимую системе для подготовки программы к выполнению. Сегмент объектного файла содержит один или несколько разделов.

Файл ELF состоит из нуля или более сегментов, и описывает, как создать процесс, образ памяти для исполнения в рантайме. Когда ядро видит эти сегменты, оно размещает их в виртуальном адресном пространстве, используя системный вызов mmap(2). Другими словами, конвертирует заранее подготовленные инструкции в образ в памяти. Если ELF-файл является обычным бинарником, он требует эти программные заголовки, иначе он просто не будет работать. Эти заголовки используются, вместе с соответствующими структурами данных, для формирования процесса. Для разделяемых библиотек (shared libraries) процесс похож.


LOAD
Определяет загружаемый сегмент, описанный p_filesz и p_memsz. Байты из файла сопоставляются с началом сегмента памяти. Если размер памяти сегмента ( p_memsz) больше, чем размер файла ( p_filesz), дополнительные байты определены для хранения значения 0 и следования за инициализированной областью сегмента. Размер файла не может быть больше размера памяти. Записи загружаемых сегментов в таблице заголовков программы отображаются в порядке возрастания, отсортированные по p_vaddrэлементу.

GNU_EH_FRAME

Это сортированная очередь, используемая компилятором GCC. В ней хранятся обработчики исключений. Если что-то пошло не так, они используются для того, чтобы корректно обработать ситуацию.

GNU_STACK

Этот заголовок используется для сохранения информации о стеке. Интересная особенность состоит в том, что стек не должен быть исполняемым, так как это может повлечь за собой уязвимости безопасности.

и т.д.



//============================
// Секции (Section Headers)
//============================

Заголовки секции определяют все секции файла. Как уже было сказано, эта информация используется для линковки и релокации. Секции появляются в ELF-файле после того, как компилятор GNU C преобразует код С в ассемблер, и ассемблер GNU создаёт объекты.

Сегмент может иметь 0 или более секций. Для исполняемых файлов существует четыре главных секций: .text, .data, .rodata, и .bss. Каждая из этих секций загружается с различными правами доступа, которые можно посмотреть с помощью readelf -S.

.text - Содержит исполняемый код. Он будет упакован в сегмент с правами на чтение и на исполнение. Он загружается один раз, и его содержание не изменяется. Это можно увидеть с помощью утилиты objdump.
.data - Инициализированные данные, с правами на чтение и запись.
.rodata - Инициализированные данные, с правами только на чтение. (=A).
.bss - Неинициализированные данные, с правами на чтение/запись. (=WA)

и т.д.


//============================
// Статические и динамические бинарные файлы
//============================

Когда мы имеем дело с бинарными файлами ELF, полезно будет знать, как линкуются эти два типа файлов. Они могут быть статическими и динамическими, и это относится к библиотекам, которые они используют. Если бинарник «динамический», это означает, что он использует внешние библиотеки, содержащие какие-либо общие функции, типа открытия файла или создания сетевого сокета. Статические бинарники, напротив, включают в себя все необходимые библиотеки.


Секции представляют собой наименьшие неделимые единицы, которые могут быть обработаны в файле ELF. Сегменты - это набор секций, представляющих наименьшие отдельные единицы, которые могут быть отображены в образ памяти с помощью exec(2) или компоновщика времени выполнения.

Секции содержат большую часть информации объектного файла для связывающего представления: инструкции, данные, таблицу символов, информацию о перемещении и так далее. Описания разделов приведены в первой части этой главы. Во второй части этой главы обсуждаются сегменты и представление выполнения программы в файле.

Таблица заголовков программы, если она присутствует, сообщает системе, как создать образ процесса. Файлы, используемые для создания образа процесса, исполняемых файлов и общих объектов, должны иметь таблицу заголовков программы; перемещаемым объектам такая таблица не нужна.

Таблица заголовков разделов содержит информацию, описывающую разделы файла. Каждый раздел имеет запись в таблице. Каждая запись содержит такую ​​информацию, как имя раздела, размер раздела и т. д. Файлы, используемые при редактировании ссылок, должны иметь таблицу заголовков разделов; другие объектные файлы могут иметь или не иметь его.


Elf32_Shdr | Elf64_Shdr - section header
Elf64_Ehdr | Elf64_Ehdr - ELF Header
Elf64_Phdr | Elf64_Phdr - program Header



//----------------------------------------------------------------------------------------------------------------------
Валидация
1. Нужно ли парсить .so как нибудь по другому?
3. nm: tests/elf-Linux-s390-bash: no symbols



Как вариант можно попробовать написать собственный elf файл, чтоб лучше в теме разобраться.
Чем отличается Таблица заголовков секций от Таблица заголовков программы?
Что такое сегмент и что такое секция?
Что такое символ и название символа более детально?

//----------------------------------------------------------------------------------------------------------------------


https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#/media/File:ELF_Executable_and_Linkable_Format_diagram_by_Ange_Albertini.png
https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter7-12.html
https://habr.com/ru/post/480642/


unsigned int | unsigned long ehdr->e_phoff
unsigned int | unsigned long ehdr->e_shoff 
unsigned short | unsigned short ehdr->e_shentsize
unsigned short | unsigned short ehdr->e_phentsize
unsigned short | unsigned short ehdr->e_shnum
unsigned short | unsigned short ehdr->e_phnum
unsigned short | unsigned short e_shstrndx